(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{405:function(t,s,a){t.exports=a.p+"assets/img/reconciler-1.75557871.png"},406:function(t,s,a){t.exports=a.p+"assets/img/reconciler-2.0ceaa119.png"},407:function(t,s,a){t.exports=a.p+"assets/img/reconciler-3.90bfbb58.png"},408:function(t,s,a){t.exports=a.p+"assets/img/reconciler-4.4ed9d954.png"},409:function(t,s,a){t.exports=a.p+"assets/img/reconciler-5.68508ec9.png"},482:function(t,s,a){"use strict";a.r(s);var e=a(14),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"实现-reconciler-架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现-reconciler-架构"}},[t._v("#")]),t._v(" 实现 Reconciler 架构")]),t._v(" "),s("p",[t._v("reconciler 是 React 核心逻辑所在的模块，中文名叫协调器。协调（reconcile）就是 diff 算法的意思。是 react 得以运行的核心包(综合协调 react-dom, react, scheduler 各包之间的调用与配合)，管理 react 应用状态的输入和结果的输出，将输入信号最终转换成输出信号传递给渲染器。")]),t._v(" "),s("h2",{attrs:{id:"reconciler有什么用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reconciler有什么用"}},[t._v("#")]),t._v(" reconciler有什么用")]),t._v(" "),s("p",[t._v("jQuery 工作原理（过程驱动）：")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:a(405)}}),t._v(" "),s("p",[t._v("前端框架结构与工作原理（状态驱动）：")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:a(406)}}),t._v(" "),s("p",[t._v("有上述两种工作原理的对比，能得知，框架的原理是通过运行时核心模块，通过输入的内容去调用宿主环境的 API")]),t._v(" "),s("p",[t._v("而以 react 框架为例流程则是：")]),t._v(" "),s("ol",[s("li",[t._v("消费 JSX")]),t._v(" "),s("li",[t._v("没有编译优化")]),t._v(" "),s("li",[t._v("开放通用 API 供不同环境使用")])]),t._v(" "),s("h2",{attrs:{id:"消费jsx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费jsx"}},[t._v("#")]),t._v(" 消费JSX")]),t._v(" "),s("h3",{attrs:{id:"选择核心模块操作的数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择核心模块操作的数据结构"}},[t._v("#")]),t._v(" 选择核心模块操作的数据结构")]),t._v(" "),s("p",[t._v("由前面实现的 JSX 方法可知，JSX 方法的返回结果是一个 ReactElement 元素，但是它作为核心模块操作的数据结构存在一些问题：")]),t._v(" "),s("ul",[s("li",[t._v("无法表达节点之间的关系（ReactElement - ReactElement）")]),t._v(" "),s("li",[t._v("字段有限，不好拓展（比如：无法表达状态）")])]),t._v(" "),s("p",[t._v("所以，需要一种新的数据结构，他的特点：")]),t._v(" "),s("ul",[s("li",[t._v("介于 ReactElement 与真实 UI 节点之间")]),t._v(" "),s("li",[t._v("能够表达节点之间的关系")]),t._v(" "),s("li",[t._v("方便拓展（不仅作为数据存储单元，也能作为工作单元）")])]),t._v(" "),s("p",[t._v("这就是 FiberNode（虚拟 DOM 在 React 中的实现）")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:a(407)}}),t._v(" "),s("h2",{attrs:{id:"reconciler的工作方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reconciler的工作方式"}},[t._v("#")]),t._v(" reconciler的工作方式")]),t._v(" "),s("p",[t._v("对于同一个节点，通过节点的 FiberNode 跟接点对应的 ReactElement 进行比较，并根据比较的结果生成不同标记（插入、删除、移动...），对应不同宿主环境API的执行，然后递归处理子节点")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:a(408)}}),t._v(" "),s("p",[t._v("比如，挂载<div></div>：")]),t._v(" "),s("div",{staticClass:"language-jsx extra-class"},[s("pre",{pre:!0,attrs:{class:"language-jsx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// React Element <div></div>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("jsx")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"div"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应fiberNode")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 生成子fiberNode")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应标记")]),t._v("\nPlacement\n")])])]),s("p",[t._v("将<div></div>更新为<p></p>：")]),t._v(" "),s("div",{staticClass:"language-jsx extra-class"},[s("pre",{pre:!0,attrs:{class:"language-jsx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// React Element <p></p>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("jsx")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"p"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应fiberNode")]),t._v("\nFiberNode "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'div'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 生成子fiberNode")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应标记")]),t._v("\nDeletion Placement\n")])])]),s("p",[t._v("当所有 ReactElement 比较完后，会生成一棵 fiberNode 树，一共会存在两棵fiberNode树：")]),t._v(" "),s("ul",[s("li",[t._v("current：与视图中真实UI对应的 fiberNode 树")]),t._v(" "),s("li",[t._v("workInProgress：触发更新后，正在 reconciler 中计算的 fiberNode 树")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/wwwlyj123321/article/details/126447825",target:"_blank",rel:"noopener noreferrer"}},[t._v("双缓冲技术介绍"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"jsx消费的顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsx消费的顺序"}},[t._v("#")]),t._v(" JSX消费的顺序")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://houbb.github.io/2020/01/23/data-struct-learn-08-dfs-bfs",target:"_blank",rel:"noopener noreferrer"}},[t._v("DFS 深度优先遍历与 BFS 广度优先遍历详解"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("以 DFS（深度优先遍历）的顺序遍历 ReactElement，这意味着：")]),t._v(" "),s("ul",[s("li",[t._v("如果有子节点，遍历子节点")]),t._v(" "),s("li",[t._v("如果没有子节点，遍历兄弟节点")])]),t._v(" "),s("p",[t._v("例子：")]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Card")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("h3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("你好"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("h3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Tiny-React"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Card")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("p",[t._v("这是个递归的过程，存在递、归两个阶段：")]),t._v(" "),s("ul",[s("li",[t._v("递：对应 beginWork")]),t._v(" "),s("li",[t._v("归：对应 completeWork")])]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:a(409)}}),t._v(" "),s("SideTitle",{attrs:{page:t.$page}})],1)}),[],!1,null,null,null);s.default=n.exports}}]);