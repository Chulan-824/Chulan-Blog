(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{383:function(v,_,t){v.exports=t.p+"assets/img/1.ea0df5f1.png"},470:function(v,_,t){"use strict";t.r(_);var e=t(14),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"初识前端框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#初识前端框架"}},[v._v("#")]),v._v(" 初识前端框架")]),v._v(" "),_("h2",{attrs:{id:"框架原理概括"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#框架原理概括"}},[v._v("#")]),v._v(" 框架原理概括")]),v._v(" "),_("p",[v._v("1.React 是库 (library) 还是框架 (framework) ?")]),v._v(" "),_("p",[v._v("2.Vue 号称是 "),_("code",[v._v("构建用户界面的渐进式框架")]),v._v("，怎么理解渐进式？")]),v._v(" "),_("p",[v._v("不管是 React 还是 Vue，他们的核心都是 "),_("code",[v._v("构建UI的库")]),v._v("，由以下两部门组成")]),v._v(" "),_("ol",[_("li",[v._v("基于状态的声明式渲染")]),v._v(" "),_("li",[v._v("组件化的层次结构")])]),v._v(" "),_("p",[v._v("随着应用复杂程度的提升，需要对不同的需求进行扩展，也有了不同的解决方案，如")]),v._v(" "),_("ul",[_("li",[v._v("状态管理的难度升级 => Redux Pinia Vuex")]),v._v(" "),_("li",[v._v("简单页面升级为SPA（Single Page Application）=> React-Router Vue-Router")]),v._v(" "),_("li",[v._v("提高首屏渲染速度、满足 SEO => SSR（Server Side Render）")])]),v._v(" "),_("p",[v._v("除上面提到的功能外，还有许多功能是 React 与 Vue 本身不包括的，比如构建支持、数据流方案、文档工具等。")]),v._v(" "),_("p",[_("strong",[v._v("所以，React 与 Vue 本身仅仅是库，而不是框架")])]),v._v(" "),_("p",[v._v('我们可以称 "包含库本身以及附加功能" 的解决方案称为框架，例如')]),v._v(" "),_("ul",[_("li",[v._v("UmiJS 是一款基于 React，内置路由、构建、部署等功能的前端框架")]),v._v(" "),_("li",[v._v("Next.js 是一款基于 React,支持 SSR、SSG（Static Site Generation，静态页面构建）的服务端框架")]),v._v(" "),_("li",[v._v("AngularJS 是一款内置多种功能的前端框架")])]),v._v(" "),_("p",[v._v("总结：")]),v._v(" "),_("ol",[_("li",[v._v("React 与 Vue 本身仅仅是库，而不是框架")]),v._v(" "),_("li",[v._v("Vue 的 “渐进式” 是指 “可以按照需求渐进地引入附加功能”，而不是像 AngularJS 一样开箱即用")])]),v._v(" "),_("h2",{attrs:{id:"初识前端框架-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#初识前端框架-2"}},[v._v("#")]),v._v(" 初识前端框架")]),v._v(" "),_("p",[v._v("几乎所有现代前端框架的实现原理都可以用一下公式替代")]),v._v(" "),_("blockquote",[_("p",[v._v("UI = "),_("em",[v._v("f")]),v._v("(state)")])]),v._v(" "),_("ul",[_("li",[v._v("state 代表 "),_("code",[v._v("当前视图状态")])]),v._v(" "),_("li",[_("em",[v._v("f")]),v._v(" 代表 "),_("code",[v._v("框架内部运行机制")])]),v._v(" "),_("li",[v._v("UI 代表 "),_("code",[v._v("宿主环境的视图")])])]),v._v(" "),_("h3",{attrs:{id:"描述ui"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#描述ui"}},[v._v("#")]),v._v(" 描述UI")]),v._v(" "),_("h4",{attrs:{id:"jsx"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[v._v("#")]),v._v(" JSX")]),v._v(" "),_("p",[v._v("React 团队认为 “UI本质上与逻辑存在耦合的部分” 例如")]),v._v(" "),_("ul",[_("li",[v._v("在 UI 上绑定事件")]),v._v(" "),_("li",[v._v("在状态变化后改变 UI 的样式或结构")])]),v._v(" "),_("p",[v._v("由于前端工程师使用 ES 编写逻辑，因此同样可以使用 ES 描述 UI，即可使用 UI 与逻辑配合更密切。至于最终方案设计为 "),_("code",[v._v("类XML")]),v._v(" 的 ES 语法糖，则是因为前端工程师更熟悉 HTML。")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("注")]),v._v(" "),_("p",[v._v("高灵活性意味着 JSX 需要牺牲 ”潜在的编译时优化空间“，后续会解释")])]),v._v(" "),_("h4",{attrs:{id:"模版语言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模版语言"}},[v._v("#")]),v._v(" 模版语言")]),v._v(" "),_("p",[v._v("在原有 HTML 语法的基础上添加了自定义语法。 比如 Vue 的 v-if、v-show、v-for，{{}}等。")]),v._v(" "),_("p",[v._v("本质是通过扩展 HTML 元素属性实现各种逻辑，这么做的好处是合法的 HTML 语法，可以直接在浏览器中正常直接显示 ”未替换的原始模版页面“。")]),v._v(" "),_("h4",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("ol",[_("li",[v._v("JSX 的出发点使用 ES 描述逻辑，就扩展 ES 语法，使它能够描述 UI，即 ”从逻辑出发扩展逻辑，描述 UI“")]),v._v(" "),_("li",[v._v("模版语法 的出发点使用 HTML 描述 UI，那就扩展 HTML,使它能够描述逻辑，即 ”从 UI 出发,扩展 UI，描述逻辑“")])]),v._v(" "),_("h3",{attrs:{id:"如何组织-ui-与逻辑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何组织-ui-与逻辑"}},[v._v("#")]),v._v(" 如何组织 UI 与逻辑")]),v._v(" "),_("p",[v._v("为了实现 UI 与逻辑的关注点分离，需要一种存放 UI 与逻辑的松散耦合单元，这就是组件")]),v._v(" "),_("p",[v._v("关于组件有两个很重要的问题需要解释")]),v._v(" "),_("ol",[_("li",[v._v("组件如何组织逻辑与 UI")]),v._v(" "),_("li",[v._v("如何在组件之间传输数据")])]),v._v(" "),_("p",[v._v('这里借助初中数学知识 "自变量与因变量",如')]),v._v(" "),_("p",[_("code",[v._v("2x + 1 = y")])]),v._v(" "),_("p",[v._v("x 的变化会导致 y 的变化，其中 x 被称为自变量，y 被称为因变量")]),v._v(" "),_("p",[v._v("定义自变量可以用 useState hooks => const [number, setNumber] = useState(0)")]),v._v(" "),_("p",[v._v("而在前端框架中，因变量又有两种类型：")]),v._v(" "),_("ol",[_("li",[v._v("无副作用因变量 => useMemo(() => 2x, [x]) (对应处理逻辑)")]),v._v(" "),_("li",[v._v("有副作用因变量 => useEffect(() => { document.title = x.value }, [x] ) (对应处理逻辑)")])]),v._v(" "),_("p",[v._v("那么我们可以得出组件内部工作流程如下图：")]),v._v(" "),_("p",[_("img",{attrs:{src:t(383),alt:""}})]),v._v(" "),_("p",[v._v("综上所述，组件通过三种方式组织逻辑与UI")]),v._v(" "),_("ol",[_("li",[v._v("逻辑中的自变量变化，导致 UI 变化")]),v._v(" "),_("li",[v._v("逻辑中的自变量变化，导致 ”无副作用因变量“ 变化，导致 UI 变化")]),v._v(" "),_("li",[v._v("逻辑中的自变量变化，导致 ”有副作用的因变量“ 变化， 导致 UI 变化")])]),v._v(" "),_("h3",{attrs:{id:"如何在组件之间传输数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何在组件之间传输数据"}},[v._v("#")]),v._v(" 如何在组件之间传输数据")]),v._v(" "),_("ol",[_("li",[v._v("React.createContext => context / context.provider useContext")]),v._v(" "),_("li",[v._v("props")]),v._v(" "),_("li",[v._v("store（Redux、Mobx、Pinia）")])]),v._v(" "),_("h3",{attrs:{id:"前端框架的分类依据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端框架的分类依据"}},[v._v("#")]),v._v(" 前端框架的分类依据")]),v._v(" "),_("p",[v._v("由上述的出的公式 "),_("code",[v._v("UI = *f*(state)")]),v._v(" 可以知道，state（自变量）,是通过直接或者间接（因变量）的方式改变 UI，而这里的 UI 仅仅是 ”对实际宿主环境 UI 的描述“，并不是实际宿主环境 UI。")]),v._v(" "),_("p",[v._v("比如")]),v._v(" "),_("div",{staticClass:"language-jsx extra-class"},[_("pre",{pre:!0,attrs:{class:"language-jsx"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" header "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),v._v("h1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),_("span",{pre:!0,attrs:{class:"token plain-text"}},[v._v("Hello World")]),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("</")]),v._v("h1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v("\n")])])]),_("p",[v._v("上述代码只是对 ”对宿主环境 UI 的描述“，通过框架处理后，在宿主环境（比如浏览器）中显示的 H1 样式的 Hello World 才是 ”真实的 UI“")]),v._v(" "),_("p",[v._v("所以公式可以拆解为一下两步：")]),v._v(" "),_("ol",[_("li",[v._v("根据自变量（state）变化计算出 UI 变化")]),v._v(" "),_("li",[v._v("根据 UI 变化执行具体的宿主环境 API （比如浏览器 DOM API）")])]),v._v(" "),_("p",[v._v('对于步骤 2，不同的前端框架的实现基本一致，差异性主要体现在步骤 1上，所以前端框架主要需要关注 "自变量与 x 的对应关系"。')]),v._v(" "),_("p",[v._v("随着 x 抽象层级不同不断下降，”自变量到 UI 变化“ 的路径越多，就意味着前端框架在运行时消耗在寻找 ”自变量与 UI 的对应关系“ 上的时间越少")]),v._v(" "),_("p",[v._v("根据 ”与自变量建立对应关系的抽象层级“ 作为其分类依据，前端框架可以分为以下三类")]),v._v(" "),_("ol",[_("li",[v._v("应用级框架 => React")]),v._v(" "),_("li",[v._v("组件级框架 => Vue")]),v._v(" "),_("li",[v._v("元素级框架 => Solid")])]),v._v(" "),_("h3",{attrs:{id:"react-中的自变量与因变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-中的自变量与因变量"}},[v._v("#")]),v._v(" React 中的自变量与因变量")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("useState")])]),v._v(" "),_("li",[_("p",[v._v("useReducer")])]),v._v(" "),_("li",[_("p",[v._v("useContext")])]),v._v(" "),_("li",[_("p",[v._v("useMemo => 采用缓存的方式 => 无副作用因变量")])]),v._v(" "),_("li",[_("p",[v._v("useCallback => 采用缓存的方式 => 无副作用因变量 => 缓存值为函数形式")])]),v._v(" "),_("li",[_("p",[v._v("useEffect => 有副作用因变量")])]),v._v(" "),_("li",[_("p",[v._v("useRef => 让 UI 与逻辑之间更灵活")])])]),v._v(" "),_("h2",{attrs:{id:"前端框架使用的技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端框架使用的技术"}},[v._v("#")]),v._v(" 前端框架使用的技术")]),v._v(" "),_("h3",{attrs:{id:"细粒度更新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#细粒度更新"}},[v._v("#")]),v._v(" 细粒度更新")]),v._v(" "),_("p",[v._v("在 Vue 和 Mobx 中使用的 ”能自动追踪依赖的技术“ 被称为 ”细粒度更新“（Finegrained Reactivity），这不是一项新技术，KnockoutJS 曾今在 2010 年采用这种技术实现 ”响应式更新“")]),v._v(" "),_("p",[v._v("这种 ”响应式更新“ 相比 React Hooks 有两个显著优点")]),v._v(" "),_("ol",[_("li",[v._v("无需显示指明依赖")]),v._v(" "),_("li",[v._v("由于可以自动跟踪依赖，因此不受 React Hooks ”不能再条件语句中声明 Hooks“ 的限制")])]),v._v(" "),_("p",[v._v("那么为什么 React Hooks 没有使用细粒度更新呢？")]),v._v(" "),_("p",[v._v("原因是 React 属于应用级框架，从关注 ”自变量与应用的对应关系“ 角度看，其更新粒度不需要很细，因此无需使用细粒度更新。作为代价，React Hooks 在使用上则会受到以上两个优点相对应的限制")]),v._v(" "),_("h3",{attrs:{id:"aot"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aot"}},[v._v("#")]),v._v(" AOT")]),v._v(" "),_("p",[v._v("现代框架都需要 ”编译“ 这一步骤，用于：")]),v._v(" "),_("ul",[_("li",[v._v("将 ”框架中描述的 UI“ 转换为宿主环境可识别的代码")]),v._v(" "),_("li",[v._v("代码转化，比如将 ts 编译为 js、实现 polyfill等")]),v._v(" "),_("li",[v._v("执行一些编译时优化")]),v._v(" "),_("li",[v._v("代码打包、压缩、混淆")])]),v._v(" "),_("p",[v._v("”编译“ 可选择两个时机执行")]),v._v(" "),_("ul",[_("li",[v._v("代码在构建时，被称为 AOT（Ahead Of Time 提前编译或预编译），宿主环境获得的是编译后的代码")]),v._v(" "),_("li",[v._v("代码在宿主环境执行时，被称为 JIT （Just In Time 即时编译），代码在宿主环境中编译并执行")])]),v._v(" "),_("p",[v._v("AOT 与 JIT 的区别包括")]),v._v(" "),_("ul",[_("li",[v._v("AOT 编译报错，JIT 宿主环境运行报错")]),v._v(" "),_("li",[v._v("使用 JIT 的应用 "),_("code",[v._v("首次加载慢于")]),v._v(" AOT 的应用，因为其需要先编译代码，AOT的应用已经在构建时完成编译，可以直接执行代码")]),v._v(" "),_("li",[v._v("使用 JIT 的应用 "),_("code",[v._v("代码体积可能大于")]),v._v(" 使用 AOT 的应用，因为运行时会增加编译器代码")])]),v._v(" "),_("p",[v._v("借助 AOT 对模版语法编译时的优化，可以减少之前提到公式工作原理的第一步 "),_("code",[v._v("根据自变量变化计算出 UI 变化")]),v._v("。这是大部分 ”采用模版语法描述 UI “的前端框架都会进行的优化，如Vue3、Angular、Svelte，因为模版语法是固定的，固定意味着 "),_("code",[v._v("可分析")]),v._v("，"),_("code",[v._v("可分析")]),v._v(" 意味着在编译时可以标记模版语法静态部分与动态部分，使步骤1在寻找 “变化的 UI” 时可以跳过静态部分。")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("注")]),v._v(" "),_("p",[v._v("AOT 能够在多大程度上减少步骤1（根据自变量变化计算出 UI 变化）视框架实现细节不同而不同")])]),v._v(" "),_("p",[v._v("可是 “采用 JSX 描述 UI” 的前端框架则难以 AOT 中收益，原因在于 JSX 是 ES 的语法糖，ES 语句的灵活性使其很难进行静态分析")]),v._v(" "),_("p",[v._v("不过有两个思路可以使 “使用 JSX 描述 UI” 的前端框架在 AOT 中收益")]),v._v(" "),_("ol",[_("li",[v._v("使用新的 AOT 实现")]),v._v(" "),_("li",[v._v("约束 JSX 的灵活性")])]),v._v(" "),_("p",[v._v("不过 Meta 正在开发的 React Forget 编译器试图来解决这方面问题")]),v._v(" "),_("h3",{attrs:{id:"virtual-dom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[v._v("#")]),v._v(" Virtual DOM")]),v._v(" "),_("p",[v._v("Virtual DOM 是实现 “根据自变量变化计算出 UI 变化” 的一种主流技术，其工作原理可以概括为两个步骤：")]),v._v(" "),_("ol",[_("li",[v._v("将 ”元素描述的 UI“ 转化为 ”VDOM 描述的 UI“")]),v._v(" "),_("li",[v._v("对比变化前后 ”VDOM 描述的 UI“，计算出 UI 中发生变化的部分")])]),v._v(" "),_("p",[v._v("VDOM 细节上 Vue 和 React 又有一些区别")]),v._v(" "),_("p",[v._v("Vue：使用 "),_("code",[v._v("模版语法")]),v._v(" 描述 UI，模版语法变异为 render 函数"),_("br"),v._v("\n1.render 函数执行后返回 ”VNode 描述的 UI“ => render"),_("br"),v._v("\n2.将变化前后 ”VNode 描述的 UI“ 进行比较，计算出 UI 中变化的部分 => patch")]),v._v(" "),_("p",[v._v("React：使用 JSX 描述 UI，JSX 编译为 createElement 方法")]),v._v(" "),_("ol",[_("li",[v._v("createElement 方法执行后返回 ”React Element 描述的 UI“")]),v._v(" "),_("li",[v._v("将 ”React Element 描述的 UI“ 与变化前 ”FiberNode 描述的 UI“ 进行比较，计算出 UI 中变化的部分，同时生成本次更新 ”FiberNode 描述的 UI“")])]),v._v(" "),_("p",[v._v("VDOM 的主要优点：")]),v._v(" "),_("ol",[_("li",[v._v("相较于 DOM 的体积优势 (DOM 包含大量冗余的属性)")]),v._v(" "),_("li",[v._v("相较于 AOT 更强大的描述能力")]),v._v(" "),_("li",[v._v("多平台渲染的抽象能力")])]),v._v(" "),_("h2",{attrs:{id:"前端框架的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端框架的实现原理"}},[v._v("#")]),v._v(" 前端框架的实现原理")]),v._v(" "),_("ol",[_("li",[v._v("Svelte：借由模版语法的约束，经过 AOT 的编译优化，直接建立 “自变量与元素的对应关系”")]),v._v(" "),_("li",[v._v("Vue3：通过 watchEffect 与自变量形成发布订阅关系，自变量变化触发 render 函数通过 patch 与 prevVDOM 进行对比更新，建立在 ”自变量与组件的对应关系“")]),v._v(" "),_("li",[v._v("React：改变自变量 => reconcile(VDOM 相关操作) => commit，每次更新都是从应用的根节点开始遍历整个应用")])]),v._v(" "),_("p",[v._v("虽然 React 每次遍历整个应用，但是性能并不会很差，一方面 React 内部有优化机制(优先级调度、Time Slice(时间切片)、Hooks、Suspense)，另一方面 React 提供了相关 API 来减少无意义的遍历，比如 shouldComponentsUpdate、React.Memo、PureComponent")]),v._v(" "),_("p",[v._v("从 ”编译时或者运行时“ 的角度看待框架")]),v._v(" "),_("ul",[_("li",[v._v("Svelte 是极致的编译时框架")]),v._v(" "),_("li",[v._v("React 是极致的运行时框架")]),v._v(" "),_("li",[v._v("Vue3 同时拥有两者的特性（AOT 和 VDOM），比较均衡")])]),v._v(" "),_("SideTitle",{attrs:{page:v.$page}})],1)}),[],!1,null,null,null);_.default=a.exports}}]);